{"version":3,"sources":["main.js","Pomelo.js","Message.js","Protocal.js","util.js","Package.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,AENA,AHSA;AELA,ADGA,AENA,AHSA;AELA,ADGA,AENA,AHSA;AELA,ADGA,AENA,AHSA,AIZA;AFOA,ADGA,AENA,AHSA,AIZA;AFOA,ADGA,AENA,AHSA,AIZA;AFOA,AGTA,AJYA,AENA,AHSA,AIZA;AFOA,AGTA,AJYA,AENA,AHSA,AIZA;AFOA,AGTA,AJYA,AENA,AHSA,AIZA;AFOA,AGTA,AJYA,AENA,AHSA,AIZA;AFOA,AGTA,AJYA,AENA,AHSA,AIZA;AFOA,AGTA,AJYA,AENA,AHSA,AIZA;AFOA,AGTA,AJYA,AENA,AHSA,AIZA;AFOA,AGTA,AJYA,AENA,AHSA,AIZA;AFOA,AGTA,AJYA,AENA,AHSA,AIZA;AFOA,AGTA,AJYA,AENA,AHSA,AIZA;AFOA,AGTA,AJYA,AENA,AHSA;AELA,AGTA,AJYA,AENA,AHSA;AELA,AGTA,AJYA,AENA,AHSA;AELA,AGTA,AJYA,AENA,AHSA;AELA,AGTA,AJYA,AENA,AHSA;AELA,AGTA,AJYA,AENA,AHSA;AELA,AGTA,AJYA,AENA,AHSA;AELA,AGTA,AJYA,AENA,AHSA;AELA,AGTA,AJYA,AENA,AHSA;AELA,AGTA,AJYA,AENA,AHSA;AELA,AGTA,AJYA,AENA,AHSA;AELA,AGTA,AJYA,AENA,AHSA;AELA,AGTA,AJYA,AENA,AHSA;AELA,AGTA,AJYA,AENA,AHSA;AELA,AGTA,AJYA,AENA,AHSA;AELA,AGTA,AJYA,AENA,AHSA;AELA,AGTA,AJYA,AENA,AHSA;AELA,AGTA,AJYA,AENA,AHSA;AELA,AGTA,AJYA,AENA,AHSA;AELA,AGTA,AJYA,AENA,AHSA;AELA,AGTA,AJYA,AENA,AHSA;AELA,AGTA,AJYA,AENA,AHSA;AELA,AGTA,AJYA,AENA,AHSA;AELA,AGTA,AJYA,AENA,AHSA;AELA,AGTA,AJYA,AENA,AHSA;AELA,AGTA,AJYA,AENA;ADIA,AGTA,AJYA,AENA;ADIA,AGTA,AJYA,AENA;ADIA,AGTA,AJYA,AENA;ADIA,AGTA,AJYA,AENA;ADIA,AGTA,AJYA,AENA;ADIA,AGTA,AJYA,AENA;ADIA,AGTA,AJYA,AENA;ADIA,AGTA,AJYA,AENA;ADIA,AGTA,AJYA,AENA;ADIA,AGTA,AJYA,AENA;ADIA,AGTA,AJYA,AENA;ADIA,AGTA,AJYA,AENA;ADIA,AGTA,AJYA,AENA;ADIA,AGTA,AJYA,AENA;ADIA,AGTA,AJYA,AENA;ADIA,AGTA,AJYA,AENA;ADIA,AGTA,AJYA,AENA;ADIA,AGTA,AJYA,AENA;ADIA,AGTA,AJYA,AENA;ADIA,AGTA,AJYA,AENA;ADIA,AGTA,AJYA,AENA;ADIA,AGTA,AJYA,AENA;ADIA,AGTA,AJYA,AENA;ADIA,AGTA,AJYA,AENA;ADIA,AGTA,AJYA,AENA;ADIA,AGTA,AJYA,AENA;ADIA,AGTA,AJYA,AENA;ADIA,AGTA,AJYA,AENA;ADIA,AGTA,AJYA,AENA;ADIA,AGTA,AJYA,AENA;ADIA,AGTA,AJYA,AENA;ADIA,AGTA,AJYA,AENA;ADIA,AGTA,AJYA,AENA;ADIA,AGTA,AJYA,AENA;ADIA,AGTA,AJYA,AENA;ADIA,AGTA,AJYA,AENA;ADIA,AGTA,AJYA,AENA;ADIA,AGTA,AJYA,AENA;ADIA,AGTA,AJYA,AENA;ADIA,AGTA,AJYA,AENA;ADIA,AGTA,AJYA,AENA;ADIA,AGTA,AJYA,AENA;ADIA,AGTA,AJYA,AENA;ADIA,AGTA,AJYA,AENA;ADIA,AGTA,AJYA,AENA;ADIA,AGTA,AJYA,AENA;ADIA,AGTA,AJYA,AENA;ADIA,AGTA,AJYA,AENA;ADIA,AGTA,AJYA,AENA;ADIA,AGTA,AJYA,AENA;ADIA,AGTA,AJYA;ACFA,AGTA,AJYA;ACFA,AGTA,AJYA;ACFA,AGTA,AJYA;ACFA,AGTA,AJYA;ACFA,AGTA,AJYA;ACFA,AGTA,AJYA;ACFA,AGTA,AJYA;ACFA,AGTA,AJYA;ACFA,AGTA,AJYA;ACFA,AGTA,AJYA;ACFA,AGTA,AJYA;ACFA,AGTA,AJYA;ACFA,AGTA,AJYA;ACFA,AGTA,AJYA;ACFA,AGTA,AJYA;ACFA,AGTA,AJYA;ACFA,AGTA,AJYA;ACFA,AGTA,AJYA;ACFA,AGTA,AJYA;ACFA,AGTA,AJYA;ACFA,AGTA,AJYA;ACFA,AGTA,AJYA;ACFA,AGTA,AJYA;ACFA,AGTA,AJYA;ACFA,AGTA,AJYA;ACFA,AGTA,AJYA;ACFA,AGTA,AJYA;ACFA,AGTA,AJYA;ACFA,AGTA,AJYA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nvar Pomelo = require('./Pomelo');\n\nfunction wsCreator(_ref) {\n    var url = _ref.url,\n        onError = _ref.onError,\n        onOpen = _ref.onOpen,\n        onMessage = _ref.onMessage,\n        onClose = _ref.onClose;\n\n    var ws = wx.connectSocket({ url: url });\n    ws.onError(onError);\n    ws.onOpen(onOpen);\n    ws.onMessage(onMessage);\n    ws.onClose(onClose);\n    return ws;\n}\n\nfunction wsCreatorWeb(_ref2) {\n    var url = _ref2.url,\n        onError = _ref2.onError,\n        onOpen = _ref2.onOpen,\n        onMessage = _ref2.onMessage,\n        onClose = _ref2.onClose;\n\n    if (false) {\n        WebSocket = require('ws');\n    }\n    var ws = new WebSocket(url);\n    ws.onerror = onError;\n    ws.onopen = onOpen;\n    ws.onmessage = onMessage;\n    ws.onclose = onClose;\n    return ws;\n}\n\nfunction urlGenerator(host, port) {\n    var url = 'wss://' + host;\n    if (port) {\n        url += '/ws/' + port + '/';\n    }\n    return url;\n}\n\nmodule.exports = new Pomelo({\n    wsCreator: wsCreator,\n    wsCreatorWeb: wsCreatorWeb,\n    urlGenerator: urlGenerator\n});","\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar EventEmitter = require('events');\nvar Message = require('./Message');\nvar Protocol = require('./Protocal');\nvar Package = require('./Package');\n\nvar DEFAULT_MAX_RECONNECT_ATTEMPTS = 10;\n\nvar JS_WS_CLIENT_TYPE = 'js-websocket';\nvar JS_WS_CLIENT_VERSION = '0.0.1';\n\nvar RES_OK = 200;\nvar RES_FAIL = 500;\nvar RES_OLD_CLIENT = 501;\n\nfunction blobToBuffer(blob, cb) {\n    if (false) {\n        var toBuffer = require('blob-to-buffer');\n        if (Buffer.isBuffer(blob)) {\n            return cb(blob);\n        }\n        return toBuffer(blob, cb);\n    }\n    var fileReader = new FileReader();\n    fileReader.onload = function (event) {\n        var buffer = event.target.result;\n        cb(buffer);\n    };\n    fileReader.readAsArrayBuffer(blob);\n}\n\nfunction defaultDecode(data) {\n    var msg = Message.decode(data);\n    msg.body = JSON.parse(Protocol.strdecode(msg.body));\n    return msg;\n}\nfunction defaultEncode(reqId, route, msg) {\n    var type = reqId ? Message.TYPE_REQUEST : Message.TYPE_NOTIFY;\n    msg = Protocol.strencode(JSON.stringify(msg));\n    var compressRoute = 0;\n    return Message.encode(reqId, type, compressRoute, route, msg);\n}\nfunction defaultUrlGenerator(host, port) {\n    var url = 'ws://' + host;\n    if (port) {\n        url += ':' + port;\n    }\n    return url;\n}\n\nmodule.exports = function (_EventEmitter) {\n    _inherits(Pomelo, _EventEmitter);\n\n    function Pomelo(args) {\n        _classCallCheck(this, Pomelo);\n\n        var _this = _possibleConstructorReturn(this, (Pomelo.__proto__ || Object.getPrototypeOf(Pomelo)).call(this, args));\n\n        var wsCreator = args.wsCreator,\n            wsCreatorWeb = args.wsCreatorWeb,\n            _args$urlGenerator = args.urlGenerator,\n            urlGenerator = _args$urlGenerator === undefined ? defaultUrlGenerator : _args$urlGenerator;\n\n        _this.wsCreator = wsCreator;\n        _this.wsCreatorWx = wsCreator;\n        _this.wsCreatorWeb = wsCreatorWeb;\n        _this.urlGenerator = urlGenerator;\n\n        _this.reconnect = false;\n        _this.reconncetTimer = null;\n        _this.reconnectAttempts = 0;\n        _this.reconnectionDelay = 5000;\n\n        _this.handshakeBuffer = {\n            'sys': {\n                type: JS_WS_CLIENT_TYPE,\n                version: JS_WS_CLIENT_VERSION,\n                rsa: {}\n            },\n            'user': {}\n        };\n\n        _this.heartbeatInterval = 0;\n        _this.heartbeatTimeout = 0;\n        _this.nextHeartbeatTimeout = 0;\n        _this.gapThreshold = 100; // heartbeat gap threashold\n        _this.heartbeatId = null;\n        _this.heartbeatTimeoutId = null;\n        _this.handshakeCallback = null;\n\n        _this.callbacks = {};\n        _this.handlers = {};\n        _this.handlers[Package.TYPE_HANDSHAKE] = _this.handshake.bind(_this);\n        _this.handlers[Package.TYPE_HEARTBEAT] = _this.heartbeat.bind(_this);\n        _this.handlers[Package.TYPE_DATA] = _this.onData.bind(_this);\n        _this.handlers[Package.TYPE_KICK] = _this.onKick.bind(_this);\n\n        _this.reqId = 0;\n        return _this;\n    }\n\n    _createClass(Pomelo, [{\n        key: 'handshake',\n        value: function handshake(data) {\n            data = JSON.parse(Protocol.strdecode(data));\n            if (data.code === RES_OLD_CLIENT) {\n                this.emit('error', 'client version not fullfill');\n                return;\n            }\n\n            if (data.code !== RES_OK) {\n                this.emit('error', 'handshake fail');\n                return;\n            }\n            this.handshakeInit(data);\n\n            var obj = Package.encode(Package.TYPE_HANDSHAKE_ACK);\n            this.send(obj);\n            this.initCallback && this.initCallback(this.socket);\n        }\n    }, {\n        key: 'handshakeInit',\n        value: function handshakeInit(data) {\n            if (data.sys && data.sys.heartbeat) {\n                this.heartbeatInterval = data.sys.heartbeat * 1000; // heartbeat interval\n                this.heartbeatTimeout = this.heartbeatInterval * 2; // max heartbeat timeout\n            } else {\n                this.heartbeatInterval = 0;\n                this.heartbeatTimeout = 0;\n            }\n\n            typeof this.handshakeCallback === 'function' && this.handshakeCallback(data.user);\n        }\n    }, {\n        key: 'heartbeat',\n        value: function heartbeat(data) {\n            var _this2 = this;\n\n            if (!this.heartbeatInterval) {\n                return;\n            }\n\n            var obj = Package.encode(Package.TYPE_HEARTBEAT);\n            if (this.heartbeatTimeoutId) {\n                clearTimeout(this.heartbeatTimeoutId);\n                this.heartbeatTimeoutId = null;\n            }\n\n            if (this.heartbeatId) {\n                // already in a heartbeat interval\n                return;\n            }\n            this.heartbeatId = setTimeout(function () {\n                _this2.heartbeatId = null;\n                _this2.send(obj);\n\n                _this2.nextHeartbeatTimeout = Date.now() + _this2.heartbeatTimeout;\n                _this2.heartbeatTimeoutId = setTimeout(function () {\n                    return _this2.heartbeatTimeoutCb();\n                }, _this2.heartbeatTimeout);\n            }, this.heartbeatInterval);\n        }\n    }, {\n        key: 'heartbeatTimeoutCb',\n        value: function heartbeatTimeoutCb() {\n            var _this3 = this;\n\n            var gap = this.nextHeartbeatTimeout - Date.now();\n            if (gap > this.gapThreshold) {\n                this.heartbeatTimeoutId = setTimeout(function () {\n                    return _this3.heartbeatTimeoutCb();\n                }, gap);\n            } else {\n                console.error('server heartbeat timeout');\n                this.emit('heartbeat timeout');\n                this.disconnect();\n            }\n        }\n    }, {\n        key: 'reset',\n        value: function reset() {\n            this.reconnect = false;\n            this.reconnectionDelay = 1000 * 5;\n            this.reconnectAttempts = 0;\n            clearTimeout(this.reconncetTimer);\n        }\n    }, {\n        key: 'init',\n        value: function init(params, cb) {\n            this.initCallback = cb;\n\n            this.params = params;\n            var host = params.host,\n                port = params.port,\n                user = params.user,\n                handshakeCallback = params.handshakeCallback,\n                _params$encode = params.encode,\n                encode = _params$encode === undefined ? defaultEncode : _params$encode,\n                _params$decode = params.decode,\n                decode = _params$decode === undefined ? defaultDecode : _params$decode,\n                debugMode = params.debugMode,\n                browserWS = params.browserWS;\n\n\n            this.encode = encode;\n            this.decode = decode;\n\n            if (debugMode) {\n                this.url = defaultUrlGenerator(host, port);\n            } else {\n                this.url = this.urlGenerator(host, port);\n            }\n\n            if (browserWS) {\n                this.wsCreator = this.wsCreatorWeb;\n                this.browserWS = browserWS;\n            }\n\n            this.handshakeBuffer.user = user;\n            this.handshakeCallback = handshakeCallback;\n            this.connect();\n        }\n    }, {\n        key: 'connect',\n        value: function connect() {\n            var _this4 = this;\n\n            var params = this.params;\n            var maxReconnectAttempts = params.maxReconnectAttempts || DEFAULT_MAX_RECONNECT_ATTEMPTS;\n            var reconnectUrl = this.url;\n\n            var onOpen = function onOpen(event) {\n                if (!!_this4.reconnect) {\n                    _this4.emit('reconnect');\n                }\n                _this4.reset();\n                var obj = Package.encode(Package.TYPE_HANDSHAKE, Protocol.strencode(JSON.stringify(_this4.handshakeBuffer)));\n                _this4.send(obj);\n            };\n            var onMessage = function onMessage(event) {\n                if (_this4.browserWS) {\n                    blobToBuffer(event.data, function (buffer) {\n                        _this4.processPackage(Package.decode(buffer));\n                        // new package arrived, update the heartbeat timeout\n                        if (_this4.heartbeatTimeout) {\n                            _this4.nextHeartbeatTimeout = Date.now() + _this4.heartbeatTimeout;\n                        }\n                    });\n                } else {\n                    _this4.processPackage(Package.decode(event.data));\n                    // new package arrived, update the heartbeat timeout\n                    if (_this4.heartbeatTimeout) {\n                        _this4.nextHeartbeatTimeout = Date.now() + _this4.heartbeatTimeout;\n                    }\n                }\n            };\n            var onError = function onError(event) {\n                _this4.emit('io-error', event);\n                console.error('socket error: ', event);\n            };\n            var onClose = function onClose(event) {\n                _this4.emit('close', event);\n                _this4.emit('disconnect', event);\n                if (!!params.reconnect && _this4.reconnectAttempts < maxReconnectAttempts) {\n                    _this4.reconnect = true;\n                    _this4.reconnectAttempts++;\n                    _this4.reconncetTimer = setTimeout(function () {\n                        return _this4.connect();\n                    }, _this4.reconnectionDelay);\n                    _this4.reconnectionDelay *= 2;\n                }\n            };\n\n            // socket = wx.connectSocket({ url: reconnectUrl });\n            this.socket = this.wsCreator({\n                url: reconnectUrl,\n                onError: onError,\n                onOpen: onOpen,\n                onMessage: onMessage,\n                onClose: onClose\n            });\n        }\n    }, {\n        key: 'disconnect',\n        value: function disconnect() {\n            if (this.socket) {\n                this.socket.close();\n                this.socket = false;\n            }\n\n            if (this.heartbeatId) {\n                clearTimeout(this.heartbeatId);\n                this.heartbeatId = null;\n            }\n            if (this.heartbeatTimeoutId) {\n                clearTimeout(this.heartbeatTimeoutId);\n                this.heartbeatTimeoutId = null;\n            }\n        }\n    }, {\n        key: 'request',\n        value: function request(route, msg, cb) {\n            if (arguments.length === 2 && typeof msg === 'function') {\n                cb = msg;\n                msg = {};\n            } else {\n                msg = msg || {};\n            }\n            route = route || msg.route;\n            if (!route) {\n                return;\n            }\n\n            this.reqId++;\n            this.sendMessage(this.reqId, route, msg);\n\n            this.callbacks[this.reqId] = cb;\n        }\n    }, {\n        key: 'notify',\n        value: function notify(route, msg) {\n            msg = msg || {};\n            this.sendMessage(0, route, msg);\n        }\n    }, {\n        key: 'sendMessage',\n        value: function sendMessage(reqId, route, msg) {\n            msg = this.encode(reqId, route, msg);\n\n            var packet = Package.encode(Package.TYPE_DATA, msg);\n            this.send(packet);\n        }\n    }, {\n        key: 'send',\n        value: function send(packet) {\n            if (this.browserWS) {\n                this.socket.send(packet.buffer);\n            } else {\n                this.socket.send({ data: packet.buffer });\n            }\n        }\n    }, {\n        key: 'onData',\n        value: function onData(msg) {\n            msg = this.decode(msg);\n            this.processMessage(msg);\n        }\n    }, {\n        key: 'onKick',\n        value: function onKick(data) {\n            data = JSON.parse(Protocol.strdecode(data));\n            this.emit('onKick', data);\n        }\n    }, {\n        key: 'processMessage',\n        value: function processMessage(msg) {\n            if (!msg.id) {\n                this.emit('onMessage', msg.route, msg.body);\n                this.emit(msg.route, msg.body);\n                return;\n            }\n\n            //if have a id then find the callback function with the request\n            var cb = this.callbacks[msg.id];\n\n            delete this.callbacks[msg.id];\n            typeof cb === 'function' && cb(msg.body);\n        }\n    }, {\n        key: 'processPackage',\n        value: function processPackage(msgs) {\n            if (Array.isArray(msgs)) {\n                for (var i = 0; i < msgs.length; i++) {\n                    var msg = msgs[i];\n                    this.handlers[msg.type](msg.body);\n                }\n            } else {\n                this.handlers[msgs.type](msgs.body);\n            }\n        }\n    }, {\n        key: 'newInstance',\n        value: function newInstance() {\n            return new Pomelo({\n                wsCreator: this.wsCreatorWx,\n                wsCreatorWx: this.wsCreatorWx,\n                wsCreatorWeb: this.wsCreatorWeb,\n                urlGenerator: this.urlGenerator\n            });\n        }\n    }]);\n\n    return Pomelo;\n}(EventEmitter);","\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Protocol = require('./Protocal');\n\nvar _require = require('./util'),\n    copyArray = _require.copyArray;\n\nvar TYPE_REQUEST = 0;\nvar TYPE_NOTIFY = 1;\nvar TYPE_RESPONSE = 2;\nvar TYPE_PUSH = 3;\n\nvar MSG_FLAG_BYTES = 1;\nvar MSG_ROUTE_CODE_BYTES = 2;\nvar MSG_ID_MAX_BYTES = 5;\nvar MSG_ROUTE_LEN_BYTES = 1;\n\nvar MSG_ROUTE_CODE_MAX = 0xffff;\n\nvar MSG_COMPRESS_ROUTE_MASK = 0x1;\nvar MSG_TYPE_MASK = 0x7;\n\nmodule.exports = function () {\n    function Message() {\n        _classCallCheck(this, Message);\n    }\n\n    _createClass(Message, null, [{\n        key: 'encode',\n\n        /**\n         * Message protocol encode.\n         *\n         * @param  {Number} id            message id\n         * @param  {Number} type          message type\n         * @param  {Number} compressRoute whether compress route\n         * @param  {Number|String} route  route code or route string\n         * @param  {Buffer} msg           message body bytes\n         * @return {Buffer}               encode result\n         */\n        value: function encode(id, type, compressRoute, route, msg) {\n            // caculate message max length\n            var idBytes = msgHasId(type) ? caculateMsgIdBytes(id) : 0;\n            var msgLen = MSG_FLAG_BYTES + idBytes;\n\n            if (msgHasRoute(type)) {\n                if (compressRoute) {\n                    if (typeof route !== 'number') {\n                        throw new Error('error flag for number route!');\n                    }\n                    msgLen += MSG_ROUTE_CODE_BYTES;\n                } else {\n                    msgLen += MSG_ROUTE_LEN_BYTES;\n                    if (route) {\n                        route = Protocol.strencode(route);\n                        if (route.length > 255) {\n                            throw new Error('route maxlength is overflow');\n                        }\n                        msgLen += route.length;\n                    }\n                }\n            }\n            if (msg) {\n                msgLen += msg.length;\n            }\n\n            var buffer = new Uint8Array(msgLen);\n            var offset = 0;\n\n            // add flag\n            offset = encodeMsgFlag(type, compressRoute, buffer, offset);\n\n            // add message id\n            if (msgHasId(type)) {\n                offset = encodeMsgId(id, buffer, offset);\n            }\n\n            // add route\n            if (msgHasRoute(type)) {\n                offset = encodeMsgRoute(compressRoute, route, buffer, offset);\n            }\n\n            // add body\n            if (msg) {\n                offset = encodeMsgBody(msg, buffer, offset);\n            }\n\n            return buffer;\n        }\n\n        /**\n         * Message protocol decode.\n         *\n         * @param  {Buffer|Uint8Array} buffer message bytes\n         * @return {Object}            message object\n         */\n\n    }, {\n        key: 'decode',\n        value: function decode(buffer) {\n            var bytes = new Uint8Array(buffer);\n            var bytesLen = bytes.length || bytes.byteLength;\n            var offset = 0;\n            var id = 0;\n            var route = null;\n\n            // parse flag\n            var flag = bytes[offset++];\n            var compressRoute = flag & MSG_COMPRESS_ROUTE_MASK;\n            var type = flag >> 1 & MSG_TYPE_MASK;\n\n            // parse id\n            if (msgHasId(type)) {\n                var m = parseInt(bytes[offset]);\n                var i = 0;\n                do {\n                    var m = parseInt(bytes[offset]);\n                    id = id + (m & 0x7f) * Math.pow(2, 7 * i);\n                    offset++;\n                    i++;\n                } while (m >= 128);\n            }\n\n            // parse route\n            if (msgHasRoute(type)) {\n                if (compressRoute) {\n                    route = bytes[offset++] << 8 | bytes[offset++];\n                } else {\n                    var routeLen = bytes[offset++];\n                    if (routeLen) {\n                        route = new Uint8Array(routeLen);\n                        copyArray(route, 0, bytes, offset, routeLen);\n                        route = Protocol.strdecode(route);\n                    } else {\n                        route = '';\n                    }\n                    offset += routeLen;\n                }\n            }\n\n            // parse body\n            var bodyLen = bytesLen - offset;\n            var body = new Uint8Array(bodyLen);\n\n            copyArray(body, 0, bytes, offset, bodyLen);\n\n            return {\n                'id': id, 'type': type, 'compressRoute': compressRoute,\n                'route': route, 'body': body\n            };\n        }\n    }, {\n        key: 'TYPE_REQUEST',\n        get: function get() {\n            return TYPE_REQUEST;\n        }\n    }, {\n        key: 'TYPE_NOTIFY',\n        get: function get() {\n            return TYPE_NOTIFY;\n        }\n    }, {\n        key: 'TYPE_RESPONSE',\n        get: function get() {\n            return TYPE_RESPONSE;\n        }\n    }, {\n        key: 'TYPE_PUSH',\n        get: function get() {\n            return TYPE_PUSH;\n        }\n    }]);\n\n    return Message;\n}();\n\nvar msgHasId = function msgHasId(type) {\n    return type === TYPE_REQUEST || type === TYPE_RESPONSE;\n};\n\nvar msgHasRoute = function msgHasRoute(type) {\n    return type === TYPE_REQUEST || type === TYPE_NOTIFY || type === TYPE_PUSH;\n};\n\nvar caculateMsgIdBytes = function caculateMsgIdBytes(id) {\n    var len = 0;\n    do {\n        len += 1;\n        id >>= 7;\n    } while (id > 0);\n    return len;\n};\n\nvar encodeMsgFlag = function encodeMsgFlag(type, compressRoute, buffer, offset) {\n    if (type !== TYPE_REQUEST && type !== TYPE_NOTIFY && type !== TYPE_RESPONSE && type !== TYPE_PUSH) {\n        throw new Error('unkonw message type: ' + type);\n    }\n\n    buffer[offset] = type << 1 | (compressRoute ? 1 : 0);\n\n    return offset + MSG_FLAG_BYTES;\n};\n\nvar encodeMsgId = function encodeMsgId(id, buffer, offset) {\n    do {\n        var tmp = id % 128;\n        var next = Math.floor(id / 128);\n\n        if (next !== 0) {\n            tmp = tmp + 128;\n        }\n        buffer[offset++] = tmp;\n\n        id = next;\n    } while (id !== 0);\n\n    return offset;\n};\n\nvar encodeMsgRoute = function encodeMsgRoute(compressRoute, route, buffer, offset) {\n    if (compressRoute) {\n        if (route > MSG_ROUTE_CODE_MAX) {\n            throw new Error('route number is overflow');\n        }\n\n        buffer[offset++] = route >> 8 & 0xff;\n        buffer[offset++] = route & 0xff;\n    } else {\n        if (route) {\n            buffer[offset++] = route.length & 0xff;\n            copyArray(buffer, offset, route, 0, route.length);\n            offset += route.length;\n        } else {\n            buffer[offset++] = 0;\n        }\n    }\n\n    return offset;\n};\n\nvar encodeMsgBody = function encodeMsgBody(msg, buffer, offset) {\n    copyArray(buffer, offset, msg, 0, msg.length);\n    return offset + msg.length;\n};","\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _require = require('./util'),\n    copyArray = _require.copyArray;\n\nmodule.exports = function () {\n    function Protocol() {\n        _classCallCheck(this, Protocol);\n    }\n\n    _createClass(Protocol, null, [{\n        key: 'strencode',\n\n        /**\n         * pomele client encode\n         * id message id;\n         * route message route\n         * msg message body\n         * socketio current support string\n         */\n        value: function strencode(str) {\n            var buffer = new Uint8Array(str.length * 3);\n            var offset = 0;\n            for (var i = 0; i < str.length; i++) {\n                var charCode = str.charCodeAt(i);\n                var codes = null;\n                if (charCode <= 0x7f) {\n                    codes = [charCode];\n                } else if (charCode <= 0x7ff) {\n                    codes = [0xc0 | charCode >> 6, 0x80 | charCode & 0x3f];\n                } else {\n                    codes = [0xe0 | charCode >> 12, 0x80 | (charCode & 0xfc0) >> 6, 0x80 | charCode & 0x3f];\n                }\n                for (var j = 0; j < codes.length; j++) {\n                    buffer[offset] = codes[j];\n                    ++offset;\n                }\n            }\n            var _buffer = new Uint8Array(offset);\n            copyArray(_buffer, 0, buffer, 0, offset);\n            return _buffer;\n        }\n    }, {\n        key: 'strdecode',\n\n\n        /**\n         * client decode\n         * msg String data\n         * return Message Object\n         */\n        value: function strdecode(buffer) {\n            var bytes = new Uint8Array(buffer);\n            var array = [];\n            var offset = 0;\n            var charCode = 0;\n            var end = bytes.length;\n            while (offset < end) {\n                if (bytes[offset] < 128) {\n                    charCode = bytes[offset];\n                    offset += 1;\n                } else if (bytes[offset] < 224) {\n                    charCode = ((bytes[offset] & 0x3f) << 6) + (bytes[offset + 1] & 0x3f);\n                    offset += 2;\n                } else if (bytes[offset] < 240) {\n                    charCode = ((bytes[offset] & 0x0f) << 12) + ((bytes[offset + 1] & 0x3f) << 6) + (bytes[offset + 2] & 0x3f);\n                    offset += 3;\n                } else if (bytes[offset] < 256) {\n                    charCode = ((bytes[offset] & 0x07) << 18) + ((bytes[offset + 1] & 0x3f) << 12) + ((bytes[offset + 2] & 0x3f) << 6) + (bytes[offset + 3] & 0x3f);\n                    offset += 4;\n                }\n                array.push(charCode);\n            }\n            // 分片处理避免无法解析过大的数据（原因暂未确认 #8）\n            var charDecoder = String.fromCodePoint ? String.fromCodePoint : String.fromCharCode;\n            var result = '';\n            var chunk = 8 * 1024;\n            var i;\n            for (i = 0; i < array.length / chunk; i++) {\n                result += charDecoder.apply(null, array.slice(i * chunk, (i + 1) * chunk));\n            }\n            result += charDecoder.apply(null, array.slice(i * chunk));\n            return result;\n        }\n    }]);\n\n    return Protocol;\n}();","\n\nmodule.exports.copyArray = function (dest, doffset, src, soffset, length) {\n    if ('function' === typeof src.copy) {\n        // Buffer\n        src.copy(dest, doffset, soffset, soffset + length);\n    } else {\n        // Uint8Array\n        for (var index = 0; index < length; index++) {\n            dest[doffset++] = src[soffset++];\n        }\n    }\n};","\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _require = require('./util'),\n    copyArray = _require.copyArray;\n\nvar PKG_HEAD_BYTES = 4;\nvar TYPE_HANDSHAKE = 1;\nvar TYPE_HANDSHAKE_ACK = 2;\nvar TYPE_HEARTBEAT = 3;\nvar TYPE_DATA = 4;\nvar TYPE_KICK = 5;\n\nmodule.exports = function () {\n    function Package() {\n        _classCallCheck(this, Package);\n    }\n\n    _createClass(Package, null, [{\n        key: 'encode',\n\n        /**\n         * Package protocol encode.\n         *\n         * Pomelo package format:\n         * +------+-------------+------------------+\n         * | type | body length |       body       |\n         * +------+-------------+------------------+\n         *\n         * Head: 4bytes\n         *   0: package type,\n         *      1 - handshake,\n         *      2 - handshake ack,\n         *      3 - heartbeat,\n         *      4 - data\n         *      5 - kick\n         *   1 - 3: big-endian body length\n         * Body: body length bytes\n         *\n         * @param  {Number}    type   package type\n         * @param  {Uint8Array} body   body content in bytes\n         * @return {Uint8Array}        new byte array that contains encode result\n         */\n        value: function encode(type, body) {\n            var length = body ? body.length : 0;\n            var buffer = new Uint8Array(PKG_HEAD_BYTES + length);\n            var index = 0;\n            buffer[index++] = type & 0xff;\n            buffer[index++] = length >> 16 & 0xff;\n            buffer[index++] = length >> 8 & 0xff;\n            buffer[index++] = length & 0xff;\n            if (body) {\n                copyArray(buffer, index, body, 0, length);\n            }\n            // return String.fromCharCode.apply(null,buffer);\n            return buffer;\n        }\n\n        /**\n         * Package protocol decode.\n         * See encode for package format.\n         *\n         * @param  {Uint8Array} buffer byte array containing package content\n         * @return {Object}           {type: package type, buffer: body byte array}\n         */\n\n    }, {\n        key: 'decode',\n        value: function decode(buffer) {\n            // buffer = toUTF8Array(str)\n            var offset = 0;\n            var bytes = new Uint8Array(buffer);\n            var length = 0;\n            var rs = [];\n            while (offset < bytes.length) {\n                var type = bytes[offset++];\n                length = (bytes[offset++] << 16 | bytes[offset++] << 8 | bytes[offset++]) >>> 0;\n                var body = length ? new Uint8Array(length) : null;\n                copyArray(body, 0, bytes, offset, length);\n                offset += length;\n                rs.push({ 'type': type, 'body': body });\n            }\n            return rs.length === 1 ? rs[0] : rs;\n        }\n    }, {\n        key: 'TYPE_HANDSHAKE',\n        get: function get() {\n            return TYPE_HANDSHAKE;\n        }\n    }, {\n        key: 'TYPE_HANDSHAKE_ACK',\n        get: function get() {\n            return TYPE_HANDSHAKE_ACK;\n        }\n    }, {\n        key: 'TYPE_HEARTBEAT',\n        get: function get() {\n            return TYPE_HEARTBEAT;\n        }\n    }, {\n        key: 'TYPE_DATA',\n        get: function get() {\n            return TYPE_DATA;\n        }\n    }, {\n        key: 'TYPE_KICK',\n        get: function get() {\n            return TYPE_KICK;\n        }\n    }]);\n\n    return Package;\n}();"]}